第一天

1.android:orientation="vertical/horizontal"  排列布局：垂直排列(水平) （在线性布局中使用成功）
2.监听按钮的点击事件：
 （1）匿名内部类监听
  btn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Log.i('tag',hello');
            }
  });
（2）类外监听
  btn1.setOnClickListener(new MyOnClickListener(){
            @Override
            public void onClick(View view) {
                super.onClick(view);
                Toast.makeText(MainActivity.this,"hello1",Toast.LENGTH_SHORT).show();
            }
  });
  Class MyOnClickListener extends OnClickListener{
	public voic OnClick(View view){
	   view.setAlpha(0.5f);
	}
  }
（3）接口方式监听
  public class MainActivity extends AppCompatActivity implements View.OnClickListener{
      btn3.setOnClickListener(this);
      public Onclick(View view){
           view.setAlpha(0.1f)
      }
  }
4.消息模式
Toast.makeText(MainActivity.this,"hello1",Toast.LENGTH_SHORT).show();
5.设置不透明度
view.setAlpha(0.5f);

第二天

1.Android : singleLine = "true"  //只能单行显示
2.设置一个控件被选中
   android:focusable="true"
   android:focusableInTouchMode="true"
3.选择跑马灯方式
   android:ellipsize="marquee"
4.设置一个类来选中控件
（1）该类继承 TextView
（2）里面的所有方法继承发类方法
（3）新建一个方法：
        @Override
        public boolean isFocused(){
             return true;
        }
5.AutoCompleteTextView 自动搜索文本框内容
     特殊属性:android:completionThreshold="2" //输入2个字节后开始自动匹配
     实现步骤：
（1）初始化控件
autoCompleteTextView = findViewById(R.id.autoCompleteTextView);
（2）初始化一个适配器
ArrayAdapter<String> adapter = new ArrayAdapter<String>(this,R.layout.support_simple_spinner_dropdown_item,res);
（3）数据资源
private String[] res = {"beijing1","beijing2","beijing3","shanghai1","shanghai2"};
（4）将控件与适配器相结合
autoCompleteTextView.setAdapter(adapter);
6.MultiAutoCompleteTextView 多次匹配搜索文本框的内容
   设置分隔符(",")方法：mtxt.setTokenizer(new MultiAutoCoompleteTextView.CommaTokenizer());
7.文本框提示信息
   android:hint="请输入你要查找的内容"
8.ToggleButton   只有选中和被选中两种状态
android:checked="true"
android:textOff="关"
android:textOn="开"
实现步骤：
(1)该类继承OnCheckedChangeListener
(2)按钮对象.setOnCheckedChangeListener(this)
(2)该类中继承的方法：
@Override
public void onCheckedChanged(CompoundButton 按钮对象名, boolean isChecked){}
9.设置图片
img.setBackgroundResource(R.drawable.picture1)
10.布局
（1）线性布局（LinearLayout）
         特有属性：
         android:orientation="horizontal/vertical"
         android:gravity="center/center_vertical/center_horizontal/right/left/bottom"
（2）相对布局（RelativeLayout）
         特有属性：
         android:layout_alignParentLeft/Top="true"
         android:layout_marginLeft="20dp"
         android:layout_centerInParent="true"
         android:layout_centerHorizontal/Vertical="true"
         android:layout_below/above="@id/button1"
         android:layout_toRightOf="@id/button1"
         android:layout_alignBaseline="@id/button1"  //内容在一条直线上
         android:layout_alignBottom="@id/button1"  //底部边缘对齐
（3）帧布局（FrameLayout）
         特有属性：
         android:layout_gravity="center/center_vertical/center_horizontal/right/left/bottom"
（4）绝对布局（AbsoluteLayout）（不能用！）
         特有属性：
         android:layout_x/y="20dp"
（5）表格布局（TableLayout）
         特有属性：
         android:collapseColumns="0,1"   //隐藏第一列和第二列
         android:shrinkColumns="*"   //所有列都可以收缩和拉伸
         android:stretchColumns="1,2"   //拉伸按钮填满空白 
         android:layout_column="1"   //该控件显示在第二列
         android:layout_span="2"   //该控件占据两列
（6）约束布局（ConstraintLayout）
         特有属性：
         app:layout_constraintRight_toRightOf="parent"
         android:layout_marginRight="10dp"
         app:layout_goneMarginRight="300dp"
         app:layout_constraintHorizontal_bias="0.9"    //水平偏右90%
         app:layout_constraintDimensionRatio="2:1"   //宽：高，其中一条边必须设置为0（相对于约束为match）
         app:layout_constraintDimensionRatio="H,2:1"   //前提:宽高都为0；高不变，宽为2:1
         app:layout_constraintHorizontal_chainStyle="spread_inside" 链布局样式之一
第三天

1.Activity
生命周期：onCreate(); onStart(); onResume(); onPause(); onStop(); onRestart(); onDestory();
2.进入其他页面的方法
（1）无返回值
Intent intent = new Intent(MainActivity.this, SecondActivity.class);
MainActivity.this.startActivity(intent);
（2）有返回值
发送请求页面：
   Intent intent = new Intent(MainActivity.this, SecondActivity.class);
   startActivityForresult(intent);
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data){  //得到返回结果的函数
    super.onActivityResult(requestCode, resultCode, data);
    if(requestCode==1 && resultCode==2){
        Log.i('tag', data.getStringExtra("data"));
    }
}
返回结果页面：
   Intent data= new Intent();
   data.putExtra("tag":"hello world!");
   setResult(2,data);  //第一个参数为结果码
   finish();   //销毁当前页面，返回上一个页面

第三天

1.在drawable中利用shape制作背景
（1）在drawable新建shape_bg.xml
（2）<corners android:radius="10dp"></corners>  //设置圆角
         <solid android:color="@color/white"/>   //设置填充色
         <gradient    //设置渐变色
           android:startColor="@color/white"
           android:endColor="@color/red"/>  
         <stroke    //设置边
           android:width="1dp"
           android:color="@color/black"/>
2.设置当前页无标题栏
在AndroidManifest.xml的activity标签中设置：android:theme="@android:style/Theme.Black.NoTitleBar"
并且把MainActivity.java中的类继承Activity
android:theme="@android:style/Theme.Black.NoTitleBar"

第四天

1.四大组件
（1）Activity
（2）Service
（3）Content Provider （内容提供者）
（4）Broadcast Receiver（广播接受者）
2.AndroidManifest中的过滤器
<activity android:name=".MainActivity2">
    <intent-filter>
        <action android:name="aaa.bbb.ccc">
        <category android:name="android.intent.category.DEFAULT">
    </intent-filter>
</activity>
java类中：
intent.setAction("aaa.bbb.ccc");
intent.addCategory("android.intent.category.DEFAULT");

第五天

1.ListView（显示列表的控件）
2.数据适配器（把复杂数据填充在指定视图界面上）
（1）ArrayAdapter
<1>初始化一个数组适配器 ，并给适配器加载数据源
arr_adapter=new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, arr_data)
//第一个参数是上下文，第二个参数是当前ListView加载的每一个列表项所对应的布局文件，第三个参数是数据源
<2>视图加载适配器
listView.setAdapter(arr_adapter)
（2）SimpleAdapter
<1>初始化一个简单适配器 ，并给适配器加载数据源
simp_adapter=new SimpleAdapter(context, data, resource, from ,to)  
//context: 上下文
//data: 数据源（格式：list里面套map；要求：from中的必须全部包含）    
//resource: 列表项的布局id
//from: Map中的键名
//to: 绑定数据视图中的id，与from成对应关系
3.监听ListView列表项点击事件
（1）OnItemClickListener
public void onItemClick（）
listView.getItemAtPosition(position) //获取点击位置对应的list的信息
（2）OnScrollListener
public void onScrollStateChanged()
能监听出三种状态：
<1>SCROLL_STATE_FLING //手指离开屏幕前用力的滑了一下，由于惯性继续滑动
监听到后可以继续加载数据源：
给数据源List中接着添加map
simp_adapter.notifyDataSetChanged() //动态更新视图
<2>SCROLL_STATE_IDLE  //视图停止滑动
<3>SCROLL_STATE_TOUCH_SCROLL  //手指没用离开屏幕
public void onScroll()

第六天

1.DataPicker
datePicker.init(year, calendar.get(Calendar.MONTH), day, new DatePicker.OnDateChangedListener() {
            @Override
            public void onDateChanged(DatePicker datePicker, int i, int i1, int i2) {
                setTitle(i+"-"+(i1+1)+"-"+i2);
            }
        });
2.TimePicker
timePicker.setOnTimeChangedListener(new TimePicker.OnTimeChangedListener() {
            @Override
            public void onTimeChanged(TimePicker timePicker, int i, int i1) {
                setTitle(i+":"+i1);
            }
        });
3.DataPickerDialog
new DatePickerDialog(this, new DatePickerDialog.OnDateSetListener() {
            @Override
            public void onDateSet(DatePicker datePicker, int i, int i1, int i2) {
                setTitle(i+"-"+(i1+1)+"-"+i2);
            }
        },year,calendar.get(Calendar.MONTH),day).show();
4.TimePickerDialog
new TimePickerDialog(this, new TimePickerDialog.OnTimeSetListener() {
            @Override
            public void onTimeSet(TimePicker timePicker, int i, int i1) {
                setTitle(i+":"+i1);
            }
        }, hour, minute, true).show();
        
第七天

1.GridView
（1）准备数据源
（2）初始化Adapt
    simpleAdapter = new SimpleAdapter(this,getDataList(),R.layout.item_layout,new String[]{"pic","text"},new int[]{R.id.imageView,R.id.text});
（3）将适配器配置到视图上
    gridView.setAdapter(simpleAdapter);
（4）设置GridView的监听事件
    gridView.setOnItemClickListener(this);
    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
        Toast.makeText(this,"我是"+iconName[i],Toast.LENGTH_SHORT).show();
    }

第八天

1.spinner下拉列表
（1）准备数据源
（2）初始化Adapter（这次用ArrayAdapter）
adapter = new ArrayAdapter<String>(this,R.layout.support_simple_spinner_dropdown_item,list);
（3）适配器加载到spinner
spinner.setAdapter((SpinnerAdapter) adapter);
（4）spinner的监听
spinner.setOnItemSelectedListener(this);
2.ProgressBar
<ProgressBar
        android:id="@+id/progressBar2"
        style="?android:attr/progressBarStyleHorizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:max="100"
        android:progress="50"
        android:secondaryProgress="80"
        app:layout_constraintTop_toBottomOf="@+id/progressBar" />
方法：
progressBar.setMax(100);
progressBar.getProgress()
progressBar.getSecondaryProgress()
progressBar.incrementProgressBy(10);
progressBar.incrementSecondaryProgressBy(10);
2.ProgressDialog
progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
progressDialog.setTitle("捉妖记2");
progressDialog.setIcon(R.drawable.icon);
progressDialog.setMax(100);
progressDialog.setMessage("欢迎来看捉妖记2");
progressDialog.incrementProgressBy(50);
progressDialog.setButton(DialogInterface.BUTTON_POSITIVE, "确定", new DialogInterface.OnClickListener(){
  @Override
  public void onClick(DialogInterface dialogInterface, int i) {
     Toast.makeText(MainActivity.this, "欢迎来看捉妖记2", Toast.LENGTH_SHORT).show();
  }
});
progressDialog.setCancelable(true);  //设置可以通过其他方式退出对话框（比如点击对话框之外的地方或者按手机物理键返回）
progressDialog.show(); 

第九天

1.WebView
（1）不用WebView访问外部（不需要加uses-permission）
Uri uri = Uri.parse(url);
Intent intent = new Intent(Intent.ACTION_VIEW, uri);
startActivity(intent);
（2）WebView访问（需要加uses-permission）
内部页面
webView.loadUrl("file:///android_asset/contentAll.html");
外部页面
webView.loadUrl("http://www.baidu.com")
2.WebViewClient（处理页面导航）
        webView.loadUrl("http://www.baidu.com");
        webView.setWebViewClient(new WebViewClient(){
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                //返回值为true时，是以WebView打开，覆盖了URL的加载；返回值时false时，是以默认浏览器或者第三方浏览器打开
                view.loadUrl(url);
                return true;
                //WebViewClient帮助WebView处理页面控制和请求通知
            }
        });
3.使页面可以加载JavaScript
WebSettings webSettings = webView.getSettings();
webSettings.setJavaScriptEnabled(true);
4.使用缓存
 webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);优先使用缓存模式
5.返回上一个页面
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode==KeyEvent.KEYCODE_BACK){
            if (webView.canGoBack()){
                webView.goBack();
                return true;
            }else{
                System.exit(0);
            }
        }
        return true;
    }
6.网页加载显示进度
        webView.setWebChromeClient(new WebChromeClient(){
            @Override
            public void onProgressChanged(WebView view, int newProgress) {
                if (newProgress==100){
                    closeDialog();
                }else{
                    openDialog(newProgress);
                }
            }
        });
    private void openDialog(int newProgress) {
        if (progressDialog==null){
            progressDialog = new ProgressDialog(this);
            progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            progressDialog.setTitle("正在加载...");
            progressDialog.setProgress(newProgress);
            progressDialog.show();
        }else{
            progressDialog.setProgress(newProgress);
        }
    }

    private void closeDialog() {
        if (progressDialog!=null&&progressDialog.isShowing()){
            progressDialog.dismiss();
            progressDialog=null;
        }
    }

第十天

1.Fragment
（1）静态加载
//进入一个新的Activity，即MainActivity2，在AndroidMani中声明：<activity android:name="com.example.fragment.MainActivity2"/>
Intent intent = new Intent(this,MainActivity2.class);
startActivity(intent)
//该Activity中可以进入到子布局文件中查询id
   setContentView(R.layout.main2);
        Button button = findViewById(R.id.button);
        button.setText("改变");
        textView = findViewById(R.id.TextView);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                textView.setText("TextView的内容改变了");
            }
        });
//布局main2声明加载MyFragment
<fragment
        android:id="@+id/fragment"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:name="com.example.fragment.MyFragment"/>
//MyFragment中继承Fragment，有onCreatView方法，其中inflater.inflate()方法，把layout布局文件转化成一个View对象
public class MyFragment extends Fragment {
    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
        //inflater.inflate()方法，把layout布局文件转化成一个View对象
        //第一个参数是需要加载的布局文件
        //第二个参数是加载Layout的父ViewGroup
        //第三个参数是boolean：如果是true，返回父的ViewGroup；如果是false，则不返回；
        View view = inflater.inflate(R.layout.myfragment,container,false);
        TextView textView = view.findViewById(R.id.TextView);
        textView.setText("静态加载");
        Button button = view.findViewById(R.id.button);
        return view;
    }
}
（2）动态加载
//声明一个继承Fragment的对象
MyFragment2 myFragment2 = new MyFragment2();
//获取管理权限
FragmentManager fragmentManager = getFragmentManager();
//开始事务
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
//对布局文件进行增（add）删（remove）改（replace）
fragmentTransaction.add(R.id.frame, myFragment2);
//设置物理返回按键
fragmentTransaction.addToBackStack(null);
//提交
fragmentTransaction.commit();
（3）生命周期
onAttach()--onCreate()--onCreateView()--onActivityCreated()--onStart()--onResume()--
onPause()--onStop()--onDestoryView()--onDestory()--onDetach()
（4）传值通信
1>Activity向Fragment传递数据，把数据存在bundle对象中
MyFragment4 myFragment4 = new MyFragment4();
Bundle bundle = new Bundle();
bundle.putString("text",text);
myFragment4.setArguments(bundle);
String text = getArguments().get("text").toString();//接收数据的方法
2>Fragment向Activity传递数据，利用接口
--首先在MyFragment类中定义一个接口
private String code = "Thank you, Activity!"; //要传送的数据
private MyResponse myResponse; //接口对象
public interface MyResponse{
        public void thank(String code);
    }
--然后在onAttach()方法中把activity对象赋值给定义的借口对象
public void onAttach(Activity activity) {
        super.onAttach(activity);
        myResponse = (MyResponse) activity;
    }
--在onCreateView()中运行接口中的方法
myResponse.thank(code);
--在Activity中继承此接口，同时也有此接口的方法，利用该方法接收到的参数就是传递的数据code
public void thank(String code) {
        Toast.makeText(MainActivity4.this,"成功接收到"+code+",客气了",Toast.LENGTH_SHORT).show();
    }

第十一天

1.ViewPager


         
         