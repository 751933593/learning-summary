## volatile关键字

#### java内存模型基础

- java内存模型的三个基本特征

  **原子性**：是指一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
  **可见性**：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行来说，可见性 问题是不存在的。
  **有序性**：在并发时，程序的执行可能会出现乱序。给人的直观感觉就是：写在前面的代码，会在后面执行。有序性问题的原 因是因为程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。

- java内存模型定义了8种操作，每一种都是原子操作

  **lock(锁定)**：作用于主内存，它把一个变量标记为一条线程独占状态；
  **read(读取)**：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；
  **load(载入)**：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；
  **use(使用)**：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；
  **assign(赋值)**：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；
  **store(存储)**：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；
  **write(写入)**：作用于主内存，它把store传送值放到主内存中的变量中。
  **unlock(解锁)**：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；
  
-  java内存模型还规定了执行上述8种基本操作时必须满足如下规则:

  ```text
  1、不允许read和load、store和write操作之一单独出现（即不允许一个变量从主存读取了但是工作内存不接受，或者从工作内存发起会写了但是主存不接受的情况），以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。
  2、不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
  3、不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。
  4、一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
  5、一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。(可重入锁)
  6、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
  7、如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
  8、对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。
  ```

#### volatile工作原理

当一个变量定义为 volatile 之后，将具备两种特性：

- **保证此变量对所有的线程的可见性**。这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 
  保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。
- **禁止指令重排序优化**。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置）。

#### 示例

```java
public class VolatileTest implements Runnable { 
    public volatile int count; 
    @Override 
    public void run() { 
        for (int i = 0; i < 100; i++) { 
            System.out.println(count++); 
        } 
    } 
    public static void main(String[] args) { 
        VolatileTest volatileTest = new VolatileTest(); 
        for (int i = 0; i < 100; i++) { 
            Thread thread = new Thread(volatileTest); thread.start(); 
        } 
    } 
}
```

执行结果：

```text
99985
99986
99987
99988
99989
99990
99991
99992
99993
99994
99995
```

分析：

  最后的结果并不是我们期望的10000，而是9995，这说明经volatile修饰的变量count并不是原子操作。其实count++在内存中的操作可分为三个步骤：
1. 从工作内存中读取count的值到线程的工作内存，即read,load阶段。
2. 在线程工作内存中计算count=count+1,即use和asign阶段。
3. 将计算后的结果刷新到主工作内存，即store和write阶段。

volatile 修饰的变量只能保证第一步的操作读取的是最新主内存工作的值，如果线程A在进行第二步的操作时，其它线程B,C…将主工作内存中的count值改变，线程A是无法感知的，还是会按照原来加载后的值继续运算。





